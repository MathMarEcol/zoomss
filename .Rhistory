for (a in 1:178){
for (b in 1:12){
out[b,a] <- sum(ar[s[[st]]])
st <- st + 1
}
}
return(out)
}
s <- list()
for (ii in 1: (12*178)) {
# print(ii)
s[[ii]] <- seq(ii,(12*178*12*178), by = 12*178)
}
system.time(v <- VecCalc(s))
system.time(b <- ArrayCalc())
b <- round(b,2)
v <- round(v,2)
identical(v,b)
out <- matrix(0,12,178)
set.seed(92136)
ar1 <- rnorm(12*178*12*178)
library(Rcpp)
sourceCpp("sum_ZooMSSC.cpp")
sc <- list()
for (ii in 1: (12*178)) {
# print(ii)
sc[[ii]] <- seq(ii-1,(12*178*12*178)-1, by = 12*178)
}
bench::mark(
round(sum_ZooMSSC(ar1,sc),2),
round(VecCalc(s),2),
round(ArrayCalc(),2)
)
sourceCpp("sum_ZooMSSC.cpp")
system.time(
c <- sum_ZooMSSC(ar1,sc[[1]])
)
## An extension of the model published in Heneghan et al., (2016):
## Models multiple zooplankton functional groups, and three fish groups
## This code is to run the model across multiple cores
##
## Jason's version for UNSWs Katana
##
## Updated Friday 31st January 2020
source("fZooMSS_Model.R") #source the model code
# Choose environmental data to use
# enviro_data <- readRDS("enviro5d.RDS") # full set of 5x5 degree grids
enviro_data <- readRDS("enviro200_20200209.RDS") # 200 square subset used for testing
enviro_data$tmaxx <- 50 # Set length of simulation (years)
#job specifics
Groups <- read.csv("TestGroups.csv") # Load in functional group information
# Should the filter feeder groups (salps/larv) have fixed PPMR?
# TRUE(default - for most runs) = YES,
# FALSE = NO (Use for PPMR=100 and PPMR=1000 runs).
fixed_filterPPMR <- TRUE
jobname <- 'DATE_JOB.NAME' #job name used on queue
ID <- as.integer(Sys.getenv('PBS_ARRAY_INDEX')) # Get the array run number
ID_char <- sprintf("%04d",ID) # Set the ID as a 4 digit character so it will sort properly
#
# out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
#               enviro_data$a[ID], enviro_data$b[ID],
#               enviro_data$phyto_max[ID], enviro_data$dt[ID],
#               enviro_data$tmaxx[ID], fixed_filterPPMR)
# saveRDS(out, file = paste0("RawOutput/", jobname, "_", ID_char,".RDS"))
# Test Run
ID <- 1
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
# Monday 17th Feb - Laptop
# system elapsed
# 25.937   4.195  30.224
# 23.865   4.227  29.192
# 21.021   4.096  25.132
# 118.380   4.793 123.178 loop with * happening every time
# 74.330   4.522  78.999  loop with * happening outside loop
# 68.684   4.437  73.287 everething outside loop
# Thursday 13th Feb - Laptop
# New N_array
# system elapsed
# 22.669   3.143  25.832
# 21.713   3.121  24.920
# 20.613   3.335  23.991
# 23.085   3.171  26.506
# 20.817   2.382  23.211
# Old N_array
# system elapsed
# 24.345   2.490  26.893
# 25.184   3.403  28.672
# 24.353   2.999  27.375
#9th Feb
# Original Code
# system elapsed
# 34.847   2.955  78.699
#
# Attempt 4
# system elapsed
# 22.544   2.474  49.315
# system elapsed
# 17.714   2.229  19.902
# Original Model- 5th Feb 2020 - iMac
# system elapsed
# 23.924   3.995  28.124
# Method 2 - 5th Feb - iMac
# system elapsed
# 22.147   1.923  24.007
# Method 4 - 5th Feb - iMac
# system elapsed
# 18.212   2.898  21.051
# system elapsed
# 17.734   2.726  20.389
## An extension of the model published in Heneghan et al., (2016):
## Models multiple zooplankton functional groups, and three fish groups
## This code is to run the model across multiple cores
##
## Jason's version for UNSWs Katana
##
## Updated Friday 31st January 2020
source("fZooMSS_Model.R") #source the model code
# Choose environmental data to use
# enviro_data <- readRDS("enviro5d.RDS") # full set of 5x5 degree grids
enviro_data <- readRDS("enviro200_20200209.RDS") # 200 square subset used for testing
enviro_data$tmaxx <- 50 # Set length of simulation (years)
#job specifics
Groups <- read.csv("TestGroups.csv") # Load in functional group information
# Should the filter feeder groups (salps/larv) have fixed PPMR?
# TRUE(default - for most runs) = YES,
# FALSE = NO (Use for PPMR=100 and PPMR=1000 runs).
fixed_filterPPMR <- TRUE
jobname <- 'DATE_JOB.NAME' #job name used on queue
ID <- as.integer(Sys.getenv('PBS_ARRAY_INDEX')) # Get the array run number
ID_char <- sprintf("%04d",ID) # Set the ID as a 4 digit character so it will sort properly
#
# out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
#               enviro_data$a[ID], enviro_data$b[ID],
#               enviro_data$phyto_max[ID], enviro_data$dt[ID],
#               enviro_data$tmaxx[ID], fixed_filterPPMR)
# saveRDS(out, file = paste0("RawOutput/", jobname, "_", ID_char,".RDS"))
# Test Run
ID <- 1
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
# Monday 17th Feb - Laptop
# system elapsed
# 25.937   4.195  30.224
# 23.865   4.227  29.192
# 21.021   4.096  25.132
# 118.380   4.793 123.178 loop with * happening every time
# 74.330   4.522  78.999  loop with * happening outside loop
# 68.684   4.437  73.287 everething outside loop
# Thursday 13th Feb - Laptop
# New N_array
# system elapsed
# 22.669   3.143  25.832
# 21.713   3.121  24.920
# 20.613   3.335  23.991
# 23.085   3.171  26.506
# 20.817   2.382  23.211
# Old N_array
# system elapsed
# 24.345   2.490  26.893
# 25.184   3.403  28.672
# 24.353   2.999  27.375
#9th Feb
# Original Code
# system elapsed
# 34.847   2.955  78.699
#
# Attempt 4
# system elapsed
# 22.544   2.474  49.315
# system elapsed
# 17.714   2.229  19.902
# Original Model- 5th Feb 2020 - iMac
# system elapsed
# 23.924   3.995  28.124
# Method 2 - 5th Feb - iMac
# system elapsed
# 22.147   1.923  24.007
# Method 4 - 5th Feb - iMac
# system elapsed
# 18.212   2.898  21.051
# system elapsed
# 17.734   2.726  20.389
## An extension of the model published in Heneghan et al., (2016):
## Models multiple zooplankton functional groups, and three fish groups
## This code is to run the model across multiple cores
##
## Jason's version for UNSWs Katana
##
## Updated Friday 31st January 2020
source("fZooMSS_Model.R") #source the model code
# Choose environmental data to use
# enviro_data <- readRDS("enviro5d.RDS") # full set of 5x5 degree grids
enviro_data <- readRDS("enviro200_20200209.RDS") # 200 square subset used for testing
enviro_data$tmaxx <- 50 # Set length of simulation (years)
#job specifics
Groups <- read.csv("TestGroups.csv") # Load in functional group information
# Should the filter feeder groups (salps/larv) have fixed PPMR?
# TRUE(default - for most runs) = YES,
# FALSE = NO (Use for PPMR=100 and PPMR=1000 runs).
fixed_filterPPMR <- TRUE
jobname <- 'DATE_JOB.NAME' #job name used on queue
ID <- as.integer(Sys.getenv('PBS_ARRAY_INDEX')) # Get the array run number
ID_char <- sprintf("%04d",ID) # Set the ID as a 4 digit character so it will sort properly
#
# out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
#               enviro_data$a[ID], enviro_data$b[ID],
#               enviro_data$phyto_max[ID], enviro_data$dt[ID],
#               enviro_data$tmaxx[ID], fixed_filterPPMR)
# saveRDS(out, file = paste0("RawOutput/", jobname, "_", ID_char,".RDS"))
# Test Run
ID <- 1
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
# Monday 17th Feb - Laptop
# system elapsed
# 25.937   4.195  30.224
# 23.865   4.227  29.192
# 21.021   4.096  25.132
# 118.380   4.793 123.178 loop with * happening every time
# 74.330   4.522  78.999  loop with * happening outside loop
# 68.684   4.437  73.287 everething outside loop
# Thursday 13th Feb - Laptop
# New N_array
# system elapsed
# 22.669   3.143  25.832
# 21.713   3.121  24.920
# 20.613   3.335  23.991
# 23.085   3.171  26.506
# 20.817   2.382  23.211
# Old N_array
# system elapsed
# 24.345   2.490  26.893
# 25.184   3.403  28.672
# 24.353   2.999  27.375
#9th Feb
# Original Code
# system elapsed
# 34.847   2.955  78.699
#
# Attempt 4
# system elapsed
# 22.544   2.474  49.315
# system elapsed
# 17.714   2.229  19.902
# Original Model- 5th Feb 2020 - iMac
# system elapsed
# 23.924   3.995  28.124
# Method 2 - 5th Feb - iMac
# system elapsed
# 22.147   1.923  24.007
# Method 4 - 5th Feb - iMac
# system elapsed
# 18.212   2.898  21.051
# system elapsed
# 17.734   2.726  20.389
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
dim((model$dynam_growthkernel)
)
p1 <- array(model$dynam_growthkernel[,,1,1],12*178)
temp_array <- array(model$dynam_growthkernel,4562496)
gk_vec <- array(model$dynam_growthkernel,4562496)
a <- 1:10
bb < 1:100
b <- 1:100
a * b
model$ngrid
model$VecLength <- model$ngrid * model*ngrps
model*ngrps
model$VecLength <- model$ngrid * model$ngrps
model$VecLength
model$ngrid
model$param$groups
model$param$ngrps
model$VecLength <- model$ngrid * model$param$ngrps
model$VecLength
gk_vec <- array(model$dynam_growthkernel,model$VecLength^2)
# Multioplly by unwrapped N
N_vec <- array(N,model$VecLength)
gg_vec <- N_vec * gk_vec
a * bb
a * b
c <- runif(100)
d <- 1
d <- 1:10
c * d
?array
class(a)
class(c)
class(gk_vec)
# Unwrap growth kernel
gk_vec <- numeric(model$dynam_growthkernel,model$VecLength^2)
?numeric
# Unwrap growth kernel
gk_vec <- as.numeric(model$dynam_growthkernel)
# Multioplly by unwrapped N
N_vec <- as.numeric(N)
gg_vec * gk_vec
N_vec * gk_vec
gg_vec <- N_vec * gk_vec
model$dynam_growthkernel*N
gk_ar <- model$dynam_growthkernel
class(N)
gg <- model$ingested_phyto + rowSums(rowSums(model$dynam_growthkernel*N_array, dims = 3), dims = 2) ### GROWTH
M2 <- rowSums(rowSums(model$dynam_mortkernel*N_array, dims = 3), dims = 2) ### MORTALITY: Predation mortality
Z <- M2 + model$M_sb  + model$fish_mort ### MORTALITY: Total dynamic spectrum mortality
diff <- model$diff_phyto + rowSums(rowSums(model$dynam_diffkernel*N_array, dims = 3), dims = 2) ### DIFFUSION
vecf <- function(){
# Multiply by unwrapped N
N_vec <- as.numeric(N)
gg_vec <- N_vec * gk_vec
M_vec <- N_vec * mk_vec
diff_vec <- N_vec * dk_vec
gg_array <- array(gg_vec[idx_array], c(12, 178, 12, 178)) # Then rearrange the vector to the order it should be
M_array <- array(M_vec[idx_array], c(12, 178, 12, 178)) # Then rearrange the vector to the order it should be
diff_array <- array(diff_vec[idx_array], c(12, 178, 12, 178)) # Then rearrange the vector to the order it should be
}
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
View(grp)
max(M2)
max(M_vec)
max(M_array)
max(gg_array)
max(gg)
max(gg_vec)
M3 <- model$dynam_mortkernel*N_array
identical(M3, M_array)
identical(round(M3,2), round(M_array,2))
ggg <- as.numeric(model$dynam_growthkernel*N_array)
identical(ggg,gg_vec)
gg{1:100}
gg[1:100]
ggg[1:100]
gg_vec[1:100]
max(gg_vec)
ggg <- as.numeric(model$dynam_growthkernel*N_array)
max(ggg)
class(N_array)
class(N)
# Unwrap matrices
N_vec <- as.numeric(t(N))
gg_vec <- N_vec * gk_vec
gg_vec[1:100]
ggg[1:100]
max(gg_vec)
N_array[1:10,1:5,,]
N_array[1:10,1:5,1,1]
N_array[1:10,1:5,2,1]
N_array[1:10,1:5,1,1]
model$dynam_growthkernel[1:10,1:5,1,1]
N_vec[1:100]
# Unwrap matrices
N_vec <- as.numeric(N)
N_vec[1:100]
model$dynam_growthkernel[1:10,1:5,1,2]
model$dynam_growthkernel[1:10,1:5,2,1]
N_array[1:10,1:5,2,1]
N_array[1:10,1:5,1,2]
model$dynam_growthkernel[1:10,1:5,1,2]
N_array_vec <- as.numeric(N_array)
N_rep_vec <- as.numeric(N,4562496)
N_rep_vec[1]
N_rep_vec[1+2136]
N_rep_vec[2130:2140]
N
N_rep_vec[179]
N_rep_vec[170:180]
N_rep_vec[1]
N_rep_vec[13]
N_rep_vec[1:20]
N_rep_vec[2130]
N_rep_vec[2130:2140]
N_rep_vec[N_rep_vec==115457124]
N_rep_vec[N_rep_vec==N_rep_vec[1]]
N_rep_vec[N_rep_vec==N_rep_vec[3]]
N_rep_vec[N_rep_vec==N_rep_vec[13]]
N_rep_vec <- as.array(N,4562496)
?as.array
View(N_rep_vec)
source("fZooMSS_Model.R") #source the model code
# Choose environmental data to use
# enviro_data <- readRDS("enviro5d.RDS") # full set of 5x5 degree grids
enviro_data <- readRDS("enviro200_20200209.RDS") # 200 square subset used for testing
enviro_data$tmaxx <- 2 # Set length of simulation (years)
#job specifics
Groups <- read.csv("TestGroups.csv") # Load in functional group information
# Should the filter feeder groups (salps/larv) have fixed PPMR?
# TRUE(default - for most runs) = YES,
# FALSE = NO (Use for PPMR=100 and PPMR=1000 runs).
fixed_filterPPMR <- TRUE
jobname <- 'DATE_JOB.NAME' #job name used on queue
ID <- as.integer(Sys.getenv('PBS_ARRAY_INDEX')) # Get the array run number
ID <- 1 # Test Run
ID_char <- sprintf("%04d",ID) # Set the ID as a 4 digit character so it will sort properly
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
## An extension of the model published in Heneghan et al., (2016):
## Models multiple zooplankton functional groups, and three fish groups
## This code is to run the model across multiple cores
##
## Jason's version for UNSWs Katana
##
## Updated Friday 31st January 2020
source("fZooMSS_Model.R") #source the model code
# Choose environmental data to use
# enviro_data <- readRDS("enviro5d.RDS") # full set of 5x5 degree grids
enviro_data <- readRDS("enviro200_20200209.RDS") # 200 square subset used for testing
enviro_data$tmaxx <- 2 # Set length of simulation (years)
#job specifics
Groups <- read.csv("TestGroups.csv") # Load in functional group information
# Should the filter feeder groups (salps/larv) have fixed PPMR?
# TRUE(default - for most runs) = YES,
# FALSE = NO (Use for PPMR=100 and PPMR=1000 runs).
fixed_filterPPMR <- TRUE
jobname <- 'DATE_JOB.NAME' #job name used on queue
ID <- as.integer(Sys.getenv('PBS_ARRAY_INDEX')) # Get the array run number
ID <- 1 # Test Run
ID_char <- sprintf("%04d",ID) # Set the ID as a 4 digit character so it will sort properly
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
# saveRDS(out, file = paste0("RawOutput/", jobname, "_", ID_char,".RDS"))
system.time(
out_3d <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
setwd("~/Dropbox/Multi-Zoo Size Spectrum Model/_LatestModel/ModelCode/OperationalCode")
source("fZooMSS_Model.R") #source the model code
# Choose environmental data to use
# enviro_data <- readRDS("enviro5d.RDS") # full set of 5x5 degree grids
enviro_data <- readRDS("enviro200_20200209.RDS") # 200 square subset used for testing
enviro_data$tmaxx <- 2 # Set length of simulation (years)
#job specifics
Groups <- read.csv("TestGroups.csv") # Load in functional group information
# Should the filter feeder groups (salps/larv) have fixed PPMR?
# TRUE(default - for most runs) = YES,
# FALSE = NO (Use for PPMR=100 and PPMR=1000 runs).
fixed_filterPPMR <- TRUE
jobname <- 'DATE_JOB.NAME' #job name used on queue
ID <- as.integer(Sys.getenv('PBS_ARRAY_INDEX')) # Get the array run number
ID <- 1 # Test Run
ID_char <- sprintf("%04d",ID) # Set the ID as a 4 digit character so it will sort properly
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
identical(out, out_3d)
identical(out$abundances, out_3d$abundances)
system.time(
out <- ZooMSS(enviro_data$sst[ID], enviro_data$chlo[ID],
enviro_data$a[ID], enviro_data$b[ID],
enviro_data$phyto_max[ID], enviro_data$dt[ID],
enviro_data$tmaxx[ID], fixed_filterPPMR)
)
identical(out$abundances, out_3d$abundances)
out$abundances[[1]]
out_3d$abundances[[1]]
out_3d$abundances - out$abundances
out_3d$abundances[1,]
out_3d$abundances[1,1:50]
out$abundances[1,1:50]
identical(out$abundances[1,1:50], out$abundances[1,1:50])
identical(out$abundances[1,1:100], out$abundances[1,1:100])
identical(out$abundances[1,1:1000], out$abundances[1,1:1000])
identical(out$abundances[1,1:500], out$abundances[1,1:500])
identical(out$abundances[1,], out$abundances[1,])
identical(out$abundances[2,], out$abundances[2,])
identical(out$abundances[3,], out$abundances[3,])
identical(out$abundances[,], out$abundances[,])
identical(out_3d$abundances[5,], out$abundances[5,])
identical(out_3d$abundances[10,], out$abundances[10,])
identical(out_3d$abundances[3,], out$abundances[3,])
identical(out_3d$abundances[1,], out$abundances[1,])
identical(out_3d$abundances[1,1:10], out$abundances[1,1:10])
(out_3d$abundances[1,1:10] - out$abundances[1,1:10])
?round
identical(round(out_3d$abundances[1,1:10],5), round(out$abundances[1,1:10],5))
identical(round(out_3d$abundances,5), round(out$abundances,5))
identical(round(out_3d$abundances,8), round(out$abundances,8))
identical(round(out_3d$abundances,7), round(out$abundances,7))
identical(round(out_3d$abundances,6), round(out$abundances,6))
